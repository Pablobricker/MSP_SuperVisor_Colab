#include <msp430.h>
#include <stdint.h>

#define NumDataRx 4
uint32_t command_dataRx[NumDataRx];              //Aqui antes estaban declarados como uint32_t
uint32_t dataW[]={0x10,0x17,0x22,0x33};

uint8_t Program_StoreAdd[7]= {0x03, 0x08, 0x00 , 0x01, 0x02, 0x03, 0x04};//Este formato es para recibir leer de FRAM

#define masterProgramSize 4
#define sizeBufferVector 223
#define FRAM_startAddress 0x00000900
#define Flash_startAddress 0x080001C0



#include <TIMERA0.h>
#include <eUSCIA1_UART.h>
#include <STMF407xx_bootloaderCommands.h>
//#include <eUSCIA0_UART.h>
#include <eUSCIB0_SPI.h>
#include <FRAM_commands.h>
#include <RTCB.h>
//#include <Reprog_comands.h>


void FRAM_REPROG(uint8_t* Global_Buffer){

    int nByt = *(Global_Buffer);

    // Setting 16-bit FRAM Address pointer
    uint16_t FRAM_WRT_PTR = *(Global_Buffer+1);
    FRAM_WRT_PTR = (FRAM_WRT_PTR <<8)| *(Global_Buffer+2);

    uint8_t data_chksum = nByt;

    int MSP2FRAMvB[25];


    int j;

    for (j=0; j<nByt; j++){
        MSP2FRAMvB[j] = *(Global_Buffer+j+3);      //salta el numero de datos y la direccion
        data_chksum = data_chksum ^ *(MSP2FRAMvB+j);
    }

    /*Estructura de datos en FRAM
    *numero de datos
    *datos
    *checksum de datos
    */
    FRAM_write((FRAM_WRT_PTR>>16)&0xFF,(FRAM_WRT_PTR>>8)&0xFF,FRAM_WRT_PTR&0xFF,&nByt,1);
    FRAM_WRT_PTR++;
    FRAM_write((FRAM_WRT_PTR>>16)&0xFF,(FRAM_WRT_PTR>>8)&0xFF,FRAM_WRT_PTR&0xFF,MSP2FRAMvB,nByt);
    FRAM_WRT_PTR=FRAM_WRT_PTR +nByt;
    FRAM_write((FRAM_WRT_PTR>>16)&0xFF,(FRAM_WRT_PTR>>8)&0xFF,FRAM_WRT_PTR&0xFF,&data_chksum,1);

}





void masterReprogramationRutine(uint32_t FRAM_initialAddress, uint32_t Flash_initialAddress1, int Rx_ready_buffers){
    uint32_t FRAM_actualAddress = FRAM_initialAddress;
    uint32_t Flash_actualAddress = Flash_initialAddress1;

    //Esta funcion asume que el respaldo del programa del master ya ha sido cargado en la FRAM.

    uint16_t FRAM2MSP_VB[25]; //Vector de Buffer de FRAM ---> MSP
    uint8_t MSP2Master_VB[25];//Vector de Buffer de MSP ---> Master La longitud del vector receptor simpre es mayor que la cantidad de datos Rx

    //int FRAMvectorBufferSize = sizeof(FRAMvectorBuffer)/sizeof(FRAMvectorBuffer[0]);
    unsigned int i;


    ACK= BootloaderAccess();
    for (i=0; i<Rx_ready_buffers; i++){

        uint16_t BFFSZ_HX;
            FRAM_read(((FRAM_actualAddress)>>16)&0xFF,((FRAM_actualAddress)>>8)&0xFF, FRAM_actualAddress&0xFF,&BFFSZ_HX, 1);
            FRAM_actualAddress++;
            int BufferVectorSize = (int) BFFSZ_HX;

            //uint16_t FRAM2MSP_VB[BufferVectorSize]; //Vector de Buffer de FRAM ---> MSP
            //uint8_t MSP2Master_VB[BufferVectorSize];//Vector de Buffer de MSP ---> Master


        FRAM_read(((FRAM_actualAddress)>>16)&0xFF,((FRAM_actualAddress)>>8)&0xFF, FRAM_actualAddress & 0xFF, FRAM2MSP_VB, BufferVectorSize);
        //Ejecutar alguna rutina para verificar la integridad de los datos (No se tiene que desarrollar ahora).
        //Hacer la conversion de 16 a 8 bits para que se puedan enviar bien los datos
        //Para mas optimizazion modificar las funciones de escritura y lectura de la FRAM a 8 bits
        //Aunque es poco probable que esto suceda ya que se necesita vaciar o llenar el buffer SPI de 16 bits para que la funcion termine.

        unsigned int j;
        for (j=0; j<=BufferVectorSize; j++){
            MSP2Master_VB[j] = FRAM2MSP_VB[j]&0xFF;}


        writeMemoryCommand(((Flash_actualAddress)>>16)&0xFFFF,(Flash_actualAddress)&0xFFFF , MSP2Master_VB, BufferVectorSize);
        FRAM_actualAddress = FRAM_actualAddress + BufferVectorSize+1;       //El +1 es para saltar el checksum
        Flash_actualAddress = Flash_actualAddress + BufferVectorSize;
    }

}




int main(void)
{

	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	//PM5CTL0 &= ~LOCKLPM5;

	P1_Init();                  //Habilita pines GPIO para el patron de acceso al bootloader
    timer_Init();               //Habilita un timer para el patron de acceso al bootloader
    eUSCIA1_UART_Init();        //Habilita comunicacion UART para conectar con Flash
    eUSCIB0_SPI_init();         //Habilita comunicacion SPI para conectar con FRAM

    //P1OUT |= BIT0;
    //P4DIR &= ~BIT2; //habilita pin P4.2 como entrada digital
    //P4IES &= ~BIT2; //la bandera de interrupcion se activa con flanco positivo.
    //P4IE |= BIT2;   //Activa la interrupciï¿½n en P4.2

    //RTC_disabling();
    //RTC_setTime(0xA,0x00);
    //RTC_setDate(0x9, 0xA, 0x7E5);
    //RTC_setAlarm(0x01);
    //RTC_enable();
    //_low_power_mode_3();
    //P1OUT &= ~BIT0;


    //Comentario pablo
//    int FRAM_dataW[892] = {     //Para escribir FRAM
//uint8_t FRAM_REACO[892] = {      //Para escribir bootloader  //Subir el programa cacho por cacho pero en la direccion de donde lo sacaste y si prende el led ya chingaste
//        // Offset 0x080001C0 to 0x0800053B
//        0xD1, 0x04, 0x00, 0x08, 0x10, 0xB5, 0x05, 0x4C, 0x23, 0x78, 0x33, 0xB9,
//        0x04, 0x4B, 0x13, 0xB1, 0x04, 0x48, 0xAF, 0xF3, 0x00, 0x80, 0x01, 0x23,
//        0x23, 0x70, 0x10, 0xBD, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
//        0x1C, 0x05, 0x00, 0x08, 0x08, 0xB5, 0x03, 0x4B, 0x1B, 0xB1, 0x03, 0x49,
//        0x03, 0x48, 0xAF, 0xF3, 0x00, 0x80, 0x08, 0xBD, 0x00, 0x00, 0x00, 0x00,
//        0x04, 0x00, 0x00, 0x20, 0x1C, 0x05, 0x00, 0x08, 0x80, 0xB4, 0x83, 0xB0,
//        0x00, 0xAF, 0x78, 0x60, 0x0B, 0x46, 0xFB, 0x70, 0x13, 0x46, 0xBB, 0x70,
//        0xBB, 0x78, 0x01, 0x2B, 0x0A, 0xD1, 0x7B, 0x68, 0x1A, 0x68, 0xFB, 0x78,
//        0x5B, 0x00, 0x01, 0x21, 0x01, 0xFA, 0x03, 0xF3, 0x1A, 0x43, 0x7B, 0x68,
//        0x1A, 0x60, 0x0A, 0xE0, 0x7B, 0x68, 0x1B, 0x68, 0xFA, 0x78, 0x52, 0x00,
//        0x03, 0x21, 0x01, 0xFA, 0x02, 0xF2, 0xD2, 0x43, 0x1A, 0x40, 0x7B, 0x68,
//        0x1A, 0x60, 0x00, 0xBF, 0x0C, 0x37, 0xBD, 0x46, 0x5D, 0xF8, 0x04, 0x7B,
//        0x70, 0x47, 0x80, 0xB4, 0x83, 0xB0, 0x00, 0xAF, 0x78, 0x60, 0x0B, 0x46,
//        0xFB, 0x70, 0x13, 0x46, 0xBB, 0x70, 0x7B, 0x68, 0x5B, 0x69, 0xFA, 0x78,
//        0x01, 0x21, 0x01, 0xFA, 0x02, 0xF2, 0xD2, 0x43, 0x1A, 0x40, 0x7B, 0x68,
//        0x5A, 0x61, 0x7B, 0x68, 0x5B, 0x69, 0xB9, 0x78, 0xFA, 0x78, 0x01, 0xFA,
//        0x02, 0xF2, 0x1A, 0x43, 0x7B, 0x68, 0x5A, 0x61, 0x00, 0xBF, 0x0C, 0x37,
//        0xBD, 0x46, 0x5D, 0xF8, 0x04, 0x7B, 0x70, 0x47, 0x80, 0xB4, 0x83, 0xB0,
//        0x00, 0xAF, 0x78, 0x60, 0x0B, 0x46, 0xFB, 0x70, 0xFB, 0x78, 0x01, 0x2B,
//        0x08, 0xD1, 0x7B, 0x68, 0x5B, 0x68, 0x1A, 0x68, 0x7B, 0x68, 0x5B, 0x68,
//        0x42, 0xF0, 0x40, 0x02, 0x1A, 0x60, 0x07, 0xE0, 0x7B, 0x68, 0x5B, 0x68,
//        0x1A, 0x68, 0x7B, 0x68, 0x5B, 0x68, 0x22, 0xF0, 0x40, 0x02, 0x1A, 0x60,
//        0x00, 0xBF, 0x0C, 0x37, 0xBD, 0x46, 0x5D, 0xF8, 0x04, 0x7B, 0x70, 0x47,
//        0x80, 0xB4, 0x85, 0xB0, 0x00, 0xAF, 0x78, 0x60, 0x7B, 0x68, 0x5B, 0x68,
//        0x9B, 0x68, 0xDB, 0xB2, 0x03, 0xF0, 0x70, 0x03, 0xFB, 0x73, 0xFB, 0x7B,
//        0x18, 0x46, 0x14, 0x37, 0xBD, 0x46, 0x5D, 0xF8, 0x04, 0x7B, 0x70, 0x47,
//        0x80, 0xB5, 0x84, 0xB0, 0x00, 0xAF, 0x78, 0x60, 0x78, 0x68, 0xFF, 0xF7,
//        0xE7, 0xFF, 0x03, 0x46, 0xBB, 0x73, 0x01, 0x23, 0xFB, 0x73, 0xBB, 0x7B,
//        0x03, 0xF0, 0x20, 0x03, 0x00, 0x2B, 0x12, 0xD0, 0x7B, 0x68, 0x5B, 0x68,
//        0x9B, 0x68, 0x7B, 0x68, 0x5B, 0x68, 0x1A, 0x68, 0x7B, 0x68, 0x5B, 0x68,
//        0x42, 0xF4, 0x80, 0x72, 0x1A, 0x60, 0xBB, 0x7B, 0x03, 0xF0, 0x20, 0x03,
//        0x00, 0x2B, 0x48, 0xD1, 0x00, 0x23, 0xFB, 0x73, 0x45, 0xE0, 0xBB, 0x7B,
//        0x03, 0xF0, 0x40, 0x03, 0x00, 0x2B, 0x0D, 0xD0, 0x7B, 0x68, 0x5B, 0x68,
//        0xDB, 0x68, 0x7B, 0x68, 0x5B, 0x68, 0x9B, 0x68, 0xBB, 0x7B, 0x03, 0xF0,
//        0x40, 0x03, 0x00, 0x2B, 0x35, 0xD1, 0x00, 0x23, 0xFB, 0x73, 0x32, 0xE0,
//        0xBB, 0x7B, 0x03, 0xF0, 0x10, 0x03, 0x00, 0x2B, 0x0F, 0xD0, 0x7B, 0x68,
//        0x5B, 0x68, 0x9A, 0x68, 0x7B, 0x68, 0x5B, 0x68, 0x22, 0xF0, 0x10, 0x02,
//        0x9A, 0x60, 0xBB, 0x7B, 0x03, 0xF0, 0x10, 0x03, 0x00, 0x2B, 0x20, 0xD1,
//        0x00, 0x23, 0xFB, 0x73, 0x1D, 0xE0, 0xBB, 0x7B, 0x03, 0xF4, 0x80, 0x73,
//        0x00, 0x2B, 0x16, 0xD0, 0x7B, 0x68, 0x5B, 0x68, 0x9B, 0x68, 0x7B, 0x68,
//        0x5B, 0x68, 0x5B, 0x68, 0x03, 0xF0, 0x20, 0x03, 0x00, 0x2B, 0x04, 0xD0,
//        0x00, 0x21, 0x78, 0x68, 0xFF, 0xF7, 0x70, 0xFF, 0x09, 0xE0, 0xBB, 0x7B,
//        0x03, 0xF4, 0x80, 0x73, 0x00, 0x2B, 0x04, 0xD1, 0x00, 0x23, 0xFB, 0x73,
//        0x01, 0xE0, 0x01, 0x23, 0xFB, 0x73, 0xFB, 0x7B, 0x18, 0x46, 0x10, 0x37,
//        0xBD, 0x46, 0x80, 0xBD, 0x80, 0xB5, 0x00, 0xAF, 0x18, 0x4B, 0x1B, 0x68,
//        0x17, 0x4A, 0x43, 0xF0, 0x01, 0x03, 0x13, 0x60, 0x01, 0x22, 0x05, 0x21,
//        0x15, 0x48, 0xFF, 0xF7, 0x0B, 0xFF, 0x01, 0x22, 0x05, 0x21, 0x13, 0x48,
//        0xFF, 0xF7, 0x2D, 0xFF, 0x12, 0x4B, 0x00, 0x22, 0x1A, 0x60, 0x04, 0xE0,
//        0x10, 0x4B, 0x1B, 0x68, 0x01, 0x33, 0x0F, 0x4A, 0x13, 0x60, 0x0E, 0x4B,
//        0x1B, 0x68, 0x0E, 0x4A, 0x93, 0x42, 0xF5, 0xDD, 0x00, 0x22, 0x05, 0x21,
//        0x09, 0x48, 0xFF, 0xF7, 0x1A, 0xFF, 0x09, 0x4B, 0x00, 0x22, 0x1A, 0x60,
//        0x04, 0xE0, 0x07, 0x4B, 0x1B, 0x68, 0x01, 0x33, 0x05, 0x4A, 0x13, 0x60,
//        0x04, 0x4B, 0x1B, 0x68, 0x04, 0x4A, 0x93, 0x42, 0xF5, 0xDD, 0xD8, 0xE7,
//        0x30, 0x38, 0x02, 0x40, 0x00, 0x00, 0x02, 0x40, 0x60, 0x00, 0x00, 0x20,
//        0x7F, 0x38, 0x01, 0x00, 0x80, 0xB5, 0x00, 0xAF, 0x0A, 0x4B, 0x5B, 0x68,
//        0x9B, 0x68, 0x03, 0xF0, 0x20, 0x03, 0x20, 0x2B, 0x06, 0xD1, 0x00, 0xBF,
//        0x06, 0x48, 0xFF, 0xF7, 0x49, 0xFF, 0x03, 0x46, 0x00, 0x2B, 0xF9, 0xD1,
//        0x03, 0x4B, 0x5B, 0x68, 0x9B, 0x68, 0x02, 0x4B, 0x5B, 0x68, 0x9B, 0x68,
//        0x00, 0xBF, 0x80, 0xBD, 0x1C, 0x00, 0x00, 0x20, 0x0D, 0x48, 0x85, 0x46,
//        0xAF, 0xF3, 0x00, 0x80, 0x0C, 0x48, 0x0D, 0x49, 0x0D, 0x4A, 0x00, 0x23,
//        0x02, 0xE0, 0xD4, 0x58, 0xC4, 0x50, 0x04, 0x33, 0xC4, 0x18, 0x8C, 0x42,
//        0xF9, 0xD3, 0x0A, 0x4A, 0x0A, 0x4C, 0x00, 0x23, 0x01, 0xE0, 0x13, 0x60,
//        0x04, 0x32, 0xA2, 0x42, 0xFB, 0xD3, 0x00, 0xF0, 0x11, 0xF8, 0xFF, 0xF7,
//        0x8F, 0xFF, 0xFE, 0xE7, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x20,
//        0x00, 0x00, 0x00, 0x20, 0x3C, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20,
//        0x64, 0x00, 0x00, 0x20, 0xFE, 0xE7, 0x00, 0x00, 0x70, 0xB5, 0x0D, 0x4D,
//        0x0D, 0x4C, 0x64, 0x1B, 0xA4, 0x10, 0x00, 0x26, 0xA6, 0x42, 0x09, 0xD1,
//        0x0B, 0x4D, 0x0C, 0x4C, 0x00, 0xF0, 0x18, 0xF8, 0x64, 0x1B, 0xA4, 0x10,
//        0x00, 0x26, 0xA6, 0x42, 0x05, 0xD1, 0x70, 0xBD, 0x55, 0xF8, 0x04, 0x3B,
//        0x98, 0x47, 0x01, 0x36, 0xEE, 0xE7, 0x55, 0xF8, 0x04, 0x3B, 0x98, 0x47,
//        0x01, 0x36, 0xF2, 0xE7, 0x34, 0x05, 0x00, 0x08, 0x34, 0x05, 0x00, 0x08,
//        0x34, 0x05, 0x00, 0x08, 0x38, 0x05, 0x00, 0x08, 0xF8, 0xB5, 0x00, 0xBF,
//        0xF8, 0xBC, 0x08, 0xBC, 0x9E, 0x46, 0x70, 0x47, 0xF8, 0xB5, 0x00, 0xBF,
//        0xF8, 0xBC, 0x08, 0xBC, 0x9E, 0x46, 0x70, 0x47, 0xE9, 0x01, 0x00, 0x08,
//        0xC5, 0x01, 0x00, 0x08
//    };



    //masterReprogramationRutine(FRAM_startAddress,Flash_startAddress);
    
    
    //ACK = BootloaderAccess();           //Solo se puede guardar hasta 256 bytes en el bootloader antes de que mande error el MSP
    //eeraseCommand(11);//stmf407 080e
    //Ultimo sector de flash de la stmf407 = 11 = 0x080E0000
    //ultimo sector de flash de la f466 = 7 = 0x08060000
    
    
    //eeraseCommand(7); // FRAM_REACO, FRAM_RdataSize  //Se puede enviar por cachos con la funcion del bootloader



    //goCommand(0x0800, 0x0000);
//uint8_t FRAM_test_Buff[4]={0x10,0x90,0x34,0x78};      //Afuerzas se tiene que leer en formato de 16 bits pq no se llena la fifo del SPI con 8
uint16_t FRAM_test_Buff[50]={0};
//FRAM_read(0x00,0x08,0x00,FRAM_test_Buff,4);



//FRAM_REPROG(Program_StoreAdd);
//FRAM_erase(0x00,0x04,0x58,36);
//FRAM_write(0x00,0x08,0x05,&data_chk,1);
//FRAM_read(0x00,0x00,0x00,FRAM_test_Buff,36);

masterReprogramationRutine(0x00000000, 0x08060000, 4);
//ACK= BootloaderAccess();
//eeraseCommand(7);
//writeMemoryCommand(0x0806,0x0000,FRAM_test_Buff,4);

goCommand(0x0800, 0x0000);
    while(1){
	}
}




#pragma vector = PORT4_VECTOR
__interrupt void PORT4_ISR(void){
    P4IFG = 0; //limpia bandera de interrupcion
    P1OUT ^= BIT0;
    _low_power_mode_off_on_exit();
}


